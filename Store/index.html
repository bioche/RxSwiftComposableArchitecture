<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComposableArchitecture - Store</title>
    <link rel="stylesheet" type="text/css" href="/swift-composable-architecture/all.css" media="all" />
</head>
<body>
    <header>
        <a href="/swift-composable-architecture/">
            <strong>
                ComposableArchitecture
            </strong>
            <span>Documentation</span>
        </a>
    </header>

    <!--
    <form class="search">
        <input type="search" placeholder="Search" />
    </form>
    -->

    <nav>
        <div class="wrapper">
            <h2>On This Page</h2>
            <ol><li><a href="#relationships">Relationships</a><ul><li><a href="#relationships">Conforms To</a></li></ul></li><li><a href="#initializers">Initializers</a><ul><li class="initializer"><a href="#store.init(initialstate:reducer:environment:)">init(initial​State:​reducer:​environment:​)</a></li></ul></li><li><a href="#properties">Properties</a><ul><li class="variable"><a href="#store.state">state</a></li><li class="variable"><a href="#store.stateless">stateless</a></li><li class="variable"><a href="#store.actionless">actionless</a></li></ul></li><li><a href="#methods">Methods</a><ul><li class="function"><a href="#store.scope(state:action:)">scope(state:​action:​)</a></li><li class="function"><a href="#store.scope(state:)">scope(state:​)</a></li><li class="function"><a href="#store.scope(state:)">scope(state:​)</a></li><li class="function"><a href="#store.scope(state:action:)">scope(state:​action:​)</a></li><li class="function"><a href="#store.scope(state:)">scope(state:​)</a></li><li class="function"><a href="#store.send(_:)">send(_:​)</a></li><li class="function"><a href="#store.scope(state:action:)">scope(state:​action:​)</a></li><li class="function"><a href="#store.driver(removeduplicates:)">driver(remove​Duplicates:​)</a></li><li class="function"><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></li><li class="function"><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></li><li class="function"><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></li><li class="function"><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></li><li class="function"><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></li><li class="function"><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></li><li class="function"><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></li><li class="function"><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></li><li class="function"><a href="#store.scopeforeach(reloadcondition:)">scope​For​Each(reload​Condition:​)</a></li><li class="function"><a href="#store.scopeforeach(reloadcondition:)">scope​For​Each(reload​Condition:​)</a></li><li class="function"><a href="#store.iflet(then:else:)">if​Let(then:​else:​)</a></li><li class="function"><a href="#store.iflet(then:)">if​Let(then:​)</a></li><li class="function"><a href="#store.iflet(then:else:)">if​Let(then:​else:​)</a></li><li class="function"><a href="#store.iflet(then:)">if​Let(then:​)</a></li><li class="function"><a href="#store.iflet(and:then:else:)">if​Let(and:​then:​else:​)</a></li><li class="function"><a href="#store.iflet(and:then:)">if​Let(and:​then:​)</a></li><li class="function"><a href="#store.onceavailable(_:thenwhennil:)">once​Available(_:​then​When​Nil:​)</a></li><li class="function"><a href="#store.onceavailable(and:then:else:)">once​Available(and:​then:​else:​)</a></li><li class="function"><a href="#store.once(_:_:thenwhenfalse:)">once(_:​_:​then​When​False:​)</a></li></ul></li></ol>
        </div>
    </nav>

    <main>
        <article>
            <h1>
    <small>Class</small>
    <code class="name">Store</code>
</h1>

<div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="attribute">final</span> <span class="keyword">class</span> <span class="type">Store</span>&lt;<span class="variable">State</span>, <span class="variable">Action</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>A store represents the runtime that powers the application. It is the object that you will pass
around to views that need to interact with the application.</p>

</div>
<div class="discussion">
    <p>You will typically construct a single one of these at the root of your application, and then use
the <code>scope</code> method to derive more focused stores that can be passed to subviews.</p>

</div>
<section id="relationships">
    <h2 hidden>Relationships</h2>
        <figure>
    <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %51 Pages: 1 -->
<svg width="872pt" height="116pt"
 viewBox="0.00 0.00 872.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>%51</title>
<polygon fill="#ffffff" stroke="transparent" points="-4,4 -4,-112 868,-112 868,4 -4,4"/>
<!-- Store -->
<g id="node1" class="node class current">
<title>Store</title>
<g id="a_node1"><a xlink:href="/swift-composable-architecture/Store" xlink:title="Store">
<path fill="none" stroke="#000000" stroke-width="3" d="M528,-108C528,-108 336,-108 336,-108 330,-108 324,-102 324,-96 324,-96 324,-84 324,-84 324,-78 330,-72 336,-72 336,-72 528,-72 528,-72 534,-72 540,-78 540,-84 540,-84 540,-96 540,-96 540,-102 534,-108 528,-108"/>
<text text-anchor="middle" x="432" y="-86.3" font-family="Menlo" font-size="14.00" fill="#000000">Store</text>
</a>
</g>
</g>
<!-- TCAIdentifiable -->
<g id="node2" class="node protocol">
<title>TCAIdentifiable</title>
<g id="a_node2"><a xlink:href="/swift-composable-architecture/TCAIdentifiable" xlink:title="TCAIdentifiable">
<path fill="none" stroke="#000000" d="M528,-36C528,-36 336,-36 336,-36 330,-36 324,-30 324,-24 324,-24 324,-12 324,-12 324,-6 330,0 336,0 336,0 528,0 528,0 534,0 540,-6 540,-12 540,-12 540,-24 540,-24 540,-30 534,-36 528,-36"/>
<text text-anchor="middle" x="432" y="-14.3" font-family="Menlo" font-size="14.00" fill="#000000">TCAIdentifiable</text>
</a>
</g>
</g>
<!-- Store&#45;&gt;TCAIdentifiable -->
<g id="edge1" class="edge conformsTo">
<title>Store&#45;&gt;TCAIdentifiable</title>
<path fill="none" stroke="#000000" d="M432,-71.8314C432,-64.131 432,-54.9743 432,-46.4166"/>
<polygon fill="#000000" stroke="#000000" points="435.5001,-46.4132 432,-36.4133 428.5001,-46.4133 435.5001,-46.4132"/>
</g>
</g>
</svg>


    <figcaption hidden>Inheritance graph for Store.</figcaption>
</figure>
        <h3>Conforms To</h3>
<dl>
    <dt class="protocol"><code><a href="/swift-composable-architecture/TCAIdentifiable">TCAIdentifiable</a></code></dt>
<dd><p>Redefinition of Apple (iOS 13 only) Identifiable protocol.
Makes it available on iOS 12 which allows full power of <code>IdentifiedArray</code> &amp; <code>Identified</code></p>
</dd>
</dl>
</section>
    <section id="initializers">
        <h2>Initializers</h2>

        <div role="article" class="initializer" id="store.init(initialstate:reducer:environment:)">
    <h3>
        <code><a href="#store.init(initialstate:reducer:environment:)">init(initial​State:​reducer:​environment:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="attribute">convenience</span> <span class="keyword">init</span>&lt;<span class="variable">Environment</span>&gt;(
    <span class="variable">initialState</span>: <span class="type">State</span>,
    <span class="variable">reducer</span>: <a href="/swift-composable-architecture/Reducer"><span class="type">Reducer</span></a>&lt;<span class="type">State</span>, <span class="type">Action</span>, <span class="type">Environment</span>&gt;,
    <span class="variable">environment</span>: <span class="type">Environment</span>
  )  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Initializes a store from an initial state, a reducer, and an environment.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>initial​State</th>
    <td><code class="type">State</code></td>
    <td><p>The state to start the application in.</p>
</td>
</tr>
<tr>
    <th>reducer</th>
    <td><code class="type">Reducer&lt;State, Action, Environment&gt;</code></td>
    <td><p>The reducer that powers the business logic of the application.</p>
</td>
</tr>
<tr>
    <th>environment</th>
    <td><code class="type">Environment</code></td>
    <td><p>The environment of dependencies for the application.</p>
</td>
</tr>
  </tbody>
</table>
</div>
    </section>
    <section id="properties">
        <h2>Properties</h2>

        <div role="article" class="variable" id="store.state">
    <h3>
        <code><a href="#store.state">state</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">internal</span>(<span class="variable">set</span>) <span class="keyword">var</span> <span class="variable">state</span>: <span class="type">State</span>  </body></html></code></pre>
</div>
</div>
<div role="article" class="variable" id="store.stateless">
    <h3>
        <code><a href="#store.stateless">stateless</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">var</span> <span class="variable">stateless</span>: <a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Void</span>, <span class="type">Action</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Returns a &quot;stateless&quot; store by erasing state to <code>Void</code>.</p>

</div>
</div>
<div role="article" class="variable" id="store.actionless">
    <h3>
        <code><a href="#store.actionless">actionless</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">var</span> <span class="variable">actionless</span>: <a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">State</span>, <span class="type">Never</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Returns an &quot;actionless&quot; store by erasing action to <code>Never</code>.</p>

</div>
</div>
    </section>
    <section id="methods">
        <h2>Methods</h2>

        <div role="article" class="function" id="store.scope(state:action:)">
    <h3>
        <code><a href="#store.scope(state:action:)">scope(state:​action:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">P</span>: <span class="type">Publisher</span>, <span class="variable">LocalState</span>, <span class="variable">LocalAction</span>&gt;(
      <span class="variable">state</span> <span class="variable">toLocalState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">AnyPublisher</span>&lt;<span class="type">State</span>, <span class="type">Never</span>&gt;) -&gt; <span class="type">P</span>,
      <span class="variable">action</span> <span class="variable">fromLocalAction</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">LocalAction</span>) -&gt; <span class="type">Action</span>
    ) -&gt; <span class="type">AnyPublisher</span>&lt;<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LocalState</span>, <span class="type">LocalAction</span>&gt;, <span class="type">Never</span>&gt;
    <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Output</span> == <span class="type">LocalState</span>, <span class="type">P</span>.<span class="type">Failure</span> == <span class="type">Never</span>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to a publisher of stores of more local state and local actions.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Local​State</th>
    <td><code class="type">@escaping (Any​Publisher&lt;State, Never&gt;) -&gt; P</code></td>
    <td><p>A function that transforms a publisher of <code>State</code> into a publisher of <code>LocalState</code>.</p>
</td>
</tr>
<tr>
    <th>from​Local​Action</th>
    <td><code class="type">@escaping (Local​Action) -&gt; Action</code></td>
    <td><p>A function that transforms <code>LocalAction</code> into <code>Action</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A publisher of stores with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.scope(state:)">
    <h3>
        <code><a href="#store.scope(state:)">scope(state:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">P</span>: <span class="type">Publisher</span>, <span class="variable">LocalState</span>&gt;(
      <span class="variable">state</span> <span class="variable">toLocalState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">AnyPublisher</span>&lt;<span class="type">State</span>, <span class="type">Never</span>&gt;) -&gt; <span class="type">P</span>
    ) -&gt; <span class="type">AnyPublisher</span>&lt;<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LocalState</span>, <span class="type">Action</span>&gt;, <span class="type">Never</span>&gt;
    <span class="keyword">where</span> <span class="type">P</span>.<span class="type">Output</span> == <span class="type">LocalState</span>, <span class="type">P</span>.<span class="type">Failure</span> == <span class="type">Never</span>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to a publisher of stores of more local state and local actions.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Local​State</th>
    <td><code class="type">@escaping (Any​Publisher&lt;State, Never&gt;) -&gt; P</code></td>
    <td><p>A function that transforms a publisher of <code>State</code> into a publisher of <code>LocalState</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A publisher of stores with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.scope(state:)">
    <h3>
        <code><a href="#store.scope(state:)">scope(state:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">LocalState</span>&gt;(
    <span class="variable">state</span> <span class="variable">toLocalState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">State</span>) -&gt; <span class="type">LocalState</span>
  ) -&gt; <a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LocalState</span>, <span class="type">Action</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to one that exposes local state.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Local​State</th>
    <td><code class="type">@escaping (State) -&gt; Local​State</code></td>
    <td><p>A function that transforms <code>State</code> into <code>LocalState</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new store with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.scope(state:action:)">
    <h3>
        <code><a href="#store.scope(state:action:)">scope(state:​action:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">O</span>: <span class="type">ObservableType</span>, <span class="variable">LocalState</span>, <span class="variable">LocalAction</span>&gt;(
    <span class="variable">state</span> <span class="variable">toLocalState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Observable</span>&lt;<span class="type">State</span>&gt;) -&gt; <span class="type">O</span>,
    <span class="variable">action</span> <span class="variable">fromLocalAction</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">LocalAction</span>) -&gt; <span class="type">Action</span>
  ) -&gt; <span class="type">Observable</span>&lt;<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LocalState</span>, <span class="type">LocalAction</span>&gt;&gt;
  <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> == <span class="type">LocalState</span>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to a publisher of stores of more local state and local actions.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Local​State</th>
    <td><code class="type">@escaping (Observable&lt;State&gt;) -&gt; O</code></td>
    <td><p>A function that transforms a publisher of <code>State</code> into a publisher of <code>LocalState</code>.</p>
</td>
</tr>
<tr>
    <th>from​Local​Action</th>
    <td><code class="type">@escaping (Local​Action) -&gt; Action</code></td>
    <td><p>A function that transforms <code>LocalAction</code> into <code>Action</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A publisher of stores with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.scope(state:)">
    <h3>
        <code><a href="#store.scope(state:)">scope(state:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">O</span>: <span class="type">ObservableType</span>, <span class="variable">LocalState</span>&gt;(
    <span class="variable">state</span> <span class="variable">toLocalState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Observable</span>&lt;<span class="type">State</span>&gt;) -&gt; <span class="type">O</span>
  ) -&gt; <span class="type">Observable</span>&lt;<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LocalState</span>, <span class="type">Action</span>&gt;&gt;
    <span class="keyword">where</span> <span class="type">O</span>.<span class="type">Element</span> == <span class="type">LocalState</span>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to a publisher of stores of more local state and local actions.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Local​State</th>
    <td><code class="type">@escaping (Observable&lt;State&gt;) -&gt; O</code></td>
    <td><p>A function that transforms a publisher of <code>State</code> into a publisher of <code>LocalState</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A publisher of stores with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.send(_:)">
    <h3>
        <code><a href="#store.send(_:)">send(_:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">send</span>(<span class="keyword">_</span> <span class="variable">action</span>: <span class="type">Action</span>)  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Sends an action to the store.</p>

</div>
<div class="discussion">
    <p><code>Store</code> is not thread safe and you should only send actions to it from the main thread.
If you are wanting to send actions on background threads due to the fact that the reducer
is performing computationally expensive work, then a better way to handle this is to wrap
that work in an <code>Effect</code> that is performed on a background thread so that the result can
be fed back into the store.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>action</th>
    <td><code class="type">Action</code></td>
    <td><p>An action.</p>
</td>
</tr>
  </tbody>
</table>
</div>
<div role="article" class="function" id="store.scope(state:action:)">
    <h3>
        <code><a href="#store.scope(state:action:)">scope(state:​action:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scope</span>&lt;<span class="variable">LocalState</span>, <span class="variable">LocalAction</span>&gt;(
    <span class="variable">state</span> <span class="variable">toLocalState</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">State</span>) -&gt; <span class="type">LocalState</span>,
    <span class="variable">action</span> <span class="variable">fromLocalAction</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">LocalAction</span>) -&gt; <span class="type">Action</span>
  ) -&gt; <a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">LocalState</span>, <span class="type">LocalAction</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Scopes the store to one that exposes local state and actions.</p>

</div>
<div class="discussion">
    <p>This can be useful for deriving new stores to hand to child views in an application. For
example:</p>

<html><body><pre class="highlight"><code><span class="comment">// Application state made from local states.</span>
<span class="keyword">struct</span> <span class="type">AppState</span> { <span class="keyword">var</span> <span class="variable">login</span>: <span class="type">LoginState</span>, ... }
<span class="keyword">struct</span> <span class="type">AppAction</span> { <span class="keyword">case</span> <span class="variable">login</span>(<span class="type">LoginAction</span>), ... }

<span class="comment">// A store that runs the entire application.</span>
<span class="keyword">let</span> <span class="variable">store</span> = <span class="variable">Store</span>(<span class="variable">initialState</span>: <span class="type">AppState</span>(), <span class="variable">reducer</span>: <span class="type">appReducer</span>, <span class="variable">environment</span>: ())

<span class="comment">// Construct a login view by scoping the store to one that works with only login domain.</span>
<span class="keyword">let</span> <span class="variable">loginView</span> = <span class="variable">LoginView</span>(
  <span class="variable">store</span>: <span class="type">store</span>.<span class="variable">scope</span>(
    <span class="variable">state</span>: { <span class="variable">$0</span>.<span class="variable">login</span> },
    <span class="variable">action</span>: { <span class="variable">AppAction</span>.<span class="variable">login</span>(<span class="variable">$0</span>) }
  )
)
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>to​Local​State</th>
    <td><code class="type">@escaping (State) -&gt; Local​State</code></td>
    <td><p>A function that transforms <code>State</code> into <code>LocalState</code>.</p>
</td>
</tr>
<tr>
    <th>from​Local​Action</th>
    <td><code class="type">@escaping (Local​Action) -&gt; Action</code></td>
    <td><p>A function that transforms <code>LocalAction</code> into <code>Action</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A new store with its domain (state and action) transformed.</p>

</div>
<div role="article" class="function" id="store.driver(removeduplicates:)">
    <h3>
        <code><a href="#store.driver(removeduplicates:)">driver(remove​Duplicates:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">driver</span>(<span class="variable">removeDuplicates</span> <span class="variable">isDuplicate</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">State</span>, <span class="type">State</span>) -&gt; <span class="type">Bool</span>) -&gt; <a href="/swift-composable-architecture/StoreDriver"><span class="type">StoreDriver</span></a>&lt;<span class="type">State</span>&gt;  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Allows observation of State from the store.
New event is not fired for duplicated state (using <code>isDuplicate</code> to detect duplicates)
Useful for UIKit controllers or coordinators as we avoid the boilerplate of having both ViewStore and Store to manage.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>is​Duplicate</th>
    <td><code class="type">@escaping (State, State) -&gt; Bool</code></td>
    <td><p>Returns true if both states should be considered equal</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A driver on the state</p>

</div>
<div role="article" class="function" id="store.bind(to:using:reloadcondition:)">
    <h3>
        <code><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">EachState</span>, <span class="variable">EachAction</span>&gt;(<span class="variable">to</span> <span class="variable">collectionView</span>: <span class="type">UICollectionView</span>,
                                          <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxFlatStoreCollectionDataSource</span>&lt;<span class="type">EachState</span>, <span class="type">EachAction</span>&gt;,
                                          <span class="variable">reloadCondition</span>: <a href="/swift-composable-architecture/ReloadCondition"><span class="type">ReloadCondition</span></a>&lt;<span class="type">EachState</span>&gt; = .<span class="variable">neverReload</span>) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">EachState</span>],
    <span class="type">EachState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>,
    <span class="type">Action</span> == (<span class="type">EachState</span>.<span class="type">ID</span>, <span class="type">EachAction</span>)  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores : one for each sub-state (<code>EachState</code>) and binds it to the collection view using the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>collection​View</th>
    <td><code class="type">UICollection​View</code></td>
    <td><p>The collection view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxFlat​Store​Collection​Data​Source&lt;Each​State, Each​Action&gt;</code></td>
    <td><p>The datasource applying the changes to the collection view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>reload​Condition</th>
    <td><code class="type">Reload​Condition&lt;Each​State&gt;</code></td>
    <td><p>By default all changes in state are to be handled by the stores. However, some changes mean a change of size of the cell. In such cases, use this closure to trigger a reload. Doesn't need to take id change into consideration as it's not a reload but a move</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the collection view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:reloadcondition:)">
    <h3>
        <code><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">EachState</span>&gt;(<span class="variable">to</span> <span class="variable">collectionView</span>: <span class="type">UICollectionView</span>,
                              <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxFlatStoreCollectionDataSource</span>&lt;<span class="type">EachState</span>, <span class="type">Action</span>&gt;,
                              <span class="variable">reloadCondition</span>: <a href="/swift-composable-architecture/ReloadCondition"><span class="type">ReloadCondition</span></a>&lt;<span class="type">EachState</span>&gt; = .<span class="variable">neverReload</span>) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">EachState</span>],
    <span class="type">EachState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores : one for each sub-state (<code>EachState</code>) and binds it to the collection view using the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>collection​View</th>
    <td><code class="type">UICollection​View</code></td>
    <td><p>The collection view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxFlat​Store​Collection​Data​Source&lt;Each​State, Action&gt;</code></td>
    <td><p>The datasource applying the changes to the collection view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>reload​Condition</th>
    <td><code class="type">Reload​Condition&lt;Each​State&gt;</code></td>
    <td><p>By default all changes in state are to be handled by the stores. However, some changes mean a change of size of the cell. In such cases, use this closure to trigger a reload. Doesn't need to take id change into consideration as it's not a reload but a move</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the collection view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:bindingconfiguration:)">
    <h3>
        <code><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">SectionState</span>, <span class="variable">SectionAction</span>, <span class="variable">ItemState</span>, <span class="variable">ItemAction</span>&gt;
    (<span class="variable">to</span> <span class="variable">collectionView</span>: <span class="type">UICollectionView</span>,
     <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxSectionedStoreCollectionDataSource</span>&lt;<span class="type">SectionState</span>, <span class="type">SectionAction</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;,
     <span class="variable">bindingConfiguration</span>: <a href="/swift-composable-architecture/SectionBindingConfiguration"><span class="type">SectionBindingConfiguration</span></a>&lt;<span class="type">SectionState</span>, <span class="type">SectionAction</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">SectionState</span>],
    <span class="type">ItemState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>, <span class="type">SectionState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>,
    <span class="type">Action</span> == (<span class="type">SectionState</span>.<span class="type">ID</span>, <span class="type">SectionAction</span>) </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores for sectioned collections : one for each sub-state (<code>SectionState</code> and <code>ItemState</code>) and binds it to the collection view using the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>collection​View</th>
    <td><code class="type">UICollection​View</code></td>
    <td><p>The collection view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxSectioned​Store​Collection​Data​Source&lt;Section​State, Section​Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The datasource applying the changes to the collection view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>binding​Configuration</th>
    <td><code class="type">Section​Binding​Configuration&lt;Section​State, Section​Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The configuration of bindings</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the collection view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:bindingconfiguration:)">
    <h3>
        <code><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">SectionState</span>, <span class="variable">ItemState</span>, <span class="variable">ItemAction</span>&gt;
  (<span class="variable">to</span> <span class="variable">collectionView</span>: <span class="type">UICollectionView</span>,
   <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxSectionedStoreCollectionDataSource</span>&lt;<span class="type">SectionState</span>, <span class="type">Action</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;,
   <span class="variable">bindingConfiguration</span>: <a href="/swift-composable-architecture/SectionBindingConfiguration"><span class="type">SectionBindingConfiguration</span></a>&lt;<span class="type">SectionState</span>, <span class="type">Action</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">SectionState</span>],
    <span class="type">ItemState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>, <span class="type">SectionState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores for sectioned collections : one for each sub-state (<code>SectionState</code> and <code>ItemState</code>) and binds it to the collection view using the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>collection​View</th>
    <td><code class="type">UICollection​View</code></td>
    <td><p>The collection view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxSectioned​Store​Collection​Data​Source&lt;Section​State, Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The datasource applying the changes to the collection view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>binding​Configuration</th>
    <td><code class="type">Section​Binding​Configuration&lt;Section​State, Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The configuration of bindings</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the collection view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:reloadcondition:)">
    <h3>
        <code><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">EachState</span>, <span class="variable">EachAction</span>&gt;(<span class="variable">to</span> <span class="variable">tableView</span>: <span class="type">UITableView</span>,
                                          <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxFlatStoreTableDataSource</span>&lt;<span class="type">EachState</span>, <span class="type">EachAction</span>&gt;,
                                          <span class="variable">reloadCondition</span>: <a href="/swift-composable-architecture/ReloadCondition"><span class="type">ReloadCondition</span></a>&lt;<span class="type">EachState</span>&gt; = .<span class="variable">neverReload</span>) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">EachState</span>],
    <span class="type">EachState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>,
    <span class="type">Action</span> == (<span class="type">EachState</span>.<span class="type">ID</span>, <span class="type">EachAction</span>)  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores : one for each sub-state (<code>EachState</code>) and binds it to the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>table​View</th>
    <td><code class="type">UITable​View</code></td>
    <td><p>The table view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxFlat​Store​Table​Data​Source&lt;Each​State, Each​Action&gt;</code></td>
    <td><p>The datasource applying the changes to the table view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>reload​Condition</th>
    <td><code class="type">Reload​Condition&lt;Each​State&gt;</code></td>
    <td><p>By default all changes in state are to be handled by the stores. However, some changes mean a change of size of the cell. In such cases, use this closure to trigger a reload.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the collection view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:reloadcondition:)">
    <h3>
        <code><a href="#store.bind(to:using:reloadcondition:)">bind(to:​using:​reload​Condition:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">EachState</span>&gt;(<span class="variable">to</span> <span class="variable">tableView</span>: <span class="type">UITableView</span>,
                              <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxFlatStoreTableDataSource</span>&lt;<span class="type">EachState</span>, <span class="type">Action</span>&gt;,
                              <span class="variable">reloadCondition</span>: <a href="/swift-composable-architecture/ReloadCondition"><span class="type">ReloadCondition</span></a>&lt;<span class="type">EachState</span>&gt; = .<span class="variable">neverReload</span>) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">EachState</span>],
    <span class="type">EachState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores : one for each sub-state (<code>EachState</code>) and binds it to the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>table​View</th>
    <td><code class="type">UITable​View</code></td>
    <td><p>The table view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxFlat​Store​Table​Data​Source&lt;Each​State, Action&gt;</code></td>
    <td><p>The datasource applying the changes to the table view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>reload​Condition</th>
    <td><code class="type">Reload​Condition&lt;Each​State&gt;</code></td>
    <td><p>By default all changes in state are to be handled by the stores. However, some changes mean a change of size of the cell. In such cases, use this closure to trigger a reload.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the collection view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:bindingconfiguration:)">
    <h3>
        <code><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">SectionState</span>, <span class="variable">SectionAction</span>, <span class="variable">ItemState</span>, <span class="variable">ItemAction</span>&gt;
    (<span class="variable">to</span> <span class="variable">tableView</span>: <span class="type">UITableView</span>,
     <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxSectionedStoreTableDataSource</span>&lt;<span class="type">SectionState</span>, <span class="type">SectionAction</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;,
     <span class="variable">bindingConfiguration</span>: <a href="/swift-composable-architecture/SectionBindingConfiguration"><span class="type">SectionBindingConfiguration</span></a>&lt;<span class="type">SectionState</span>, <span class="type">SectionAction</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">SectionState</span>],
    <span class="type">ItemState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>, <span class="type">SectionState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>,
    <span class="type">Action</span> == (<span class="type">SectionState</span>.<span class="type">ID</span>, <span class="type">SectionAction</span>) </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores for sectioned tables : one for each sub-state (<code>SectionState</code> and <code>ItemState</code>) and binds it to the table view using the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>table​View</th>
    <td><code class="type">UITable​View</code></td>
    <td><p>The table view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxSectioned​Store​Table​Data​Source&lt;Section​State, Section​Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The datasource applying the changes to the collection view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>binding​Configuration</th>
    <td><code class="type">Section​Binding​Configuration&lt;Section​State, Section​Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The configuration of bindings</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the table view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.bind(to:using:bindingconfiguration:)">
    <h3>
        <code><a href="#store.bind(to:using:bindingconfiguration:)">bind(to:​using:​binding​Configuration:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">bind</span>&lt;<span class="variable">SectionState</span>, <span class="variable">ItemState</span>, <span class="variable">ItemAction</span>&gt;
  (<span class="variable">to</span> <span class="variable">tableView</span>: <span class="type">UITableView</span>,
   <span class="variable">using</span> <span class="variable">datasource</span>: <span class="type">RxSectionedStoreTableDataSource</span>&lt;<span class="type">SectionState</span>, <span class="type">Action</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;,
   <span class="variable">bindingConfiguration</span>: <a href="/swift-composable-architecture/SectionBindingConfiguration"><span class="type">SectionBindingConfiguration</span></a>&lt;<span class="type">SectionState</span>, <span class="type">Action</span>, <span class="type">ItemState</span>, <span class="type">ItemAction</span>&gt;) -&gt; <span class="type">Disposable</span>
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">SectionState</span>],
    <span class="type">ItemState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>, <span class="type">SectionState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Splits the original store into multiple stores for sectioned tables : one for each sub-state (<code>SectionState</code> and <code>ItemState</code>) and binds it to the table view using the provided <code>datasource</code>.</p>

</div>
<div class="discussion">
    <p>The datasource can be customized to apply of changes using the method of your choosing : Import the <code>ComposableDifferenceKitDatasources</code> framework to use <code>DifferenceKit</code>.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>table​View</th>
    <td><code class="type">UITable​View</code></td>
    <td><p>The table view to be populated</p>
</td>
</tr>
<tr>
    <th>datasource</th>
    <td><code class="type">RxSectioned​Store​Table​Data​Source&lt;Section​State, Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The datasource applying the changes to the collection view using the closure it was initialized with</p>
</td>
</tr>
<tr>
    <th>binding​Configuration</th>
    <td><code class="type">Section​Binding​Configuration&lt;Section​State, Action, Item​State, Item​Action&gt;</code></td>
    <td><p>The configuration of bindings</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>Disposable to be disposed whenever the table view doesn't need filling anymore</p>

</div>
<div role="article" class="function" id="store.scopeforeach(reloadcondition:)">
    <h3>
        <code><a href="#store.scopeforeach(reloadcondition:)">scope​For​Each(reload​Condition:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scopeForEach</span>&lt;<span class="variable">EachState</span>&gt;(<span class="variable">reloadCondition</span>: <a href="/swift-composable-architecture/ReloadCondition"><span class="type">ReloadCondition</span></a>&lt;<span class="type">EachState</span>&gt; = .<span class="variable">neverReload</span>) -&gt; <span class="type">Driver</span>&lt;[<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">EachState</span>, <span class="type">Action</span>&gt;]&gt;
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">EachState</span>], <span class="type">EachState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Gives the evolution of a  list of stores scoped down to each element of this store.
This avoids reloading entire collections / tables when only a property of an element is updated.
The elements must be Identifiable so that we can publish a new array when an identity has changed at a specific index.
For SwiftUI, prefer the ForEachStore</p>

</div>
</div>
<div role="article" class="function" id="store.scopeforeach(reloadcondition:)">
    <h3>
        <code><a href="#store.scopeforeach(reloadcondition:)">scope​For​Each(reload​Condition:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">scopeForEach</span>&lt;<span class="variable">EachState</span>, <span class="variable">EachAction</span>&gt;(<span class="variable">reloadCondition</span>: <a href="/swift-composable-architecture/ReloadCondition"><span class="type">ReloadCondition</span></a>&lt;<span class="type">EachState</span>&gt; = .<span class="variable">neverReload</span>) -&gt; <span class="type">Driver</span>&lt;[<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">EachState</span>, <span class="type">EachAction</span>&gt;]&gt;
    <span class="keyword">where</span> <span class="type">State</span> == [<span class="type">EachState</span>], <span class="type">EachState</span>: <a href="/swift-composable-architecture/TCAIdentifiable"><span class="type">TCAIdentifiable</span></a>, <span class="type">Action</span> == (<span class="type">EachState</span>.<span class="type">ID</span>, <span class="type">EachAction</span>)  </body></html></code></pre>
</div>
</div>
<div role="article" class="function" id="store.iflet(then:else:)">
    <h3>
        <code><a href="#store.iflet(then:else:)">if​Let(then:​else:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>,
    <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Cancellable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Subscribes to updates when a store containing optional state goes from <code>nil</code> to non-<code>nil</code> or
non-<code>nil</code> to <code>nil</code>.</p>

</div>
<div class="discussion">
    <p>This is useful for handling navigation in UIKit. The state for a screen that you want to
navigate to can be held as an optional value in the parent, and when that value switches
from <code>nil</code> to non-<code>nil</code> you want to trigger a navigation and hand the detail view a <code>Store</code>
whose domain has been scoped to just that feature:</p>

<html><body><pre class="highlight"><code><span class="keyword">class</span> <span class="type">MasterViewController</span>: <span class="type">UIViewController</span> {
  <span class="keyword">let</span> <span class="variable">store</span>: <a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">MasterState</span>, <span class="type">MasterAction</span>&gt;
  <span class="keyword">var</span> <span class="variable">cancellables</span>: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
  ...
  <span class="keyword">func</span> <span class="function">viewDidLoad</span>() {
    ...
    <span class="keyword">self</span>.<span class="variable">store</span>
      .<span class="variable">scope</span>(<span class="variable">state</span>: \.<span class="variable">optionalDetail</span>, <span class="variable">action</span>: <span class="type">MasterAction</span>.<span class="variable">detail</span>)
      .<span class="variable">ifLet</span>(
        <span class="variable">then</span>: { [<span class="variable">weak</span> <span class="keyword">self</span>] <span class="variable">detailStore</span> <span class="keyword">in</span>
          <span class="keyword">self</span>?.<span class="variable">navigationController</span>?.<span class="variable">pushViewController</span>(
            <span class="variable">DetailViewController</span>(<span class="variable">store</span>: <span class="type">detailStore</span>),
            <span class="variable">animated</span>: <span class="keyword">true</span>
          )
        },
        <span class="variable">else</span>: { [<span class="variable">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span>
          <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
          <span class="keyword">self</span>.<span class="variable">navigationController</span>?.<span class="variable">popToViewController</span>(<span class="keyword">self</span>, <span class="variable">animated</span>: <span class="keyword">true</span>)
        }
      )
      .<span class="variable">store</span>(<span class="variable">in</span>: &amp;<span class="keyword">self</span>.<span class="variable">cancellables</span>)
  }
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Void</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code>.</p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping () -&gt; Void</code></td>
    <td><p>A function that is called whenever the store's optional state goes from non-<code>nil</code> to <code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A cancellable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.iflet(then:)">
    <h3>
        <code><a href="#store.iflet(then:)">if​Let(then:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Cancellable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>An overload of <code>ifLet(then:else:)</code> for the times that you do not want to handle the <code>else</code>
case.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Void</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A cancellable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.iflet(then:else:)">
    <h3>
        <code><a href="#store.iflet(then:else:)">if​Let(then:​else:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>,
    <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Subscribes to updates when a store containing optional state goes from <code>nil</code> to non-<code>nil</code> or
non-<code>nil</code> to <code>nil</code>.</p>

</div>
<div class="discussion">
    <p>This is useful for handling navigation in UIKit. The state for a screen that you want to
navigate to can be held as an optional value in the parent, and when that value switches
from <code>nil</code> to non-<code>nil</code> you want to trigger a navigation and hand the detail view a <code>Store</code>
whose domain has been scoped to just that feature:</p>

<html><body><pre class="highlight"><code><span class="keyword">class</span> <span class="type">MasterViewController</span>: <span class="type">UIViewController</span> {
  <span class="keyword">let</span> <span class="variable">store</span>: <a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">MasterState</span>, <span class="type">MasterAction</span>&gt;
  <span class="keyword">let</span> <span class="variable">disposeBag</span> = <span class="variable">DisposeBag</span>()
  ...
  <span class="keyword">func</span> <span class="function">viewDidLoad</span>() {
    ...
    <span class="keyword">self</span>.<span class="variable">store</span>
      .<span class="variable">scope</span>(<span class="variable">state</span>: \.<span class="variable">optionalDetail</span>, <span class="variable">action</span>: <span class="type">MasterAction</span>.<span class="variable">detail</span>)
      .<span class="variable">ifLet</span>(
        <span class="variable">then</span>: { [<span class="variable">weak</span> <span class="keyword">self</span>] <span class="variable">detailStore</span> <span class="keyword">in</span>
          <span class="keyword">self</span>?.<span class="variable">navigationController</span>?.<span class="variable">pushViewController</span>(
            <span class="variable">DetailViewController</span>(<span class="variable">store</span>: <span class="type">detailStore</span>),
            <span class="variable">animated</span>: <span class="keyword">true</span>
          )
        },
        <span class="variable">else</span>: { [<span class="variable">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span>
          <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
          <span class="keyword">self</span>.<span class="variable">navigationController</span>?.<span class="variable">popToViewController</span>(<span class="keyword">self</span>, <span class="variable">animated</span>: <span class="keyword">true</span>)
        }
      )
      .<span class="variable">disposed</span>(<span class="variable">by</span>: <span class="type">disposeBag</span>)
  }
}
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Void</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code>.</p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping () -&gt; Void</code></td>
    <td><p>A function that is called whenever the store's optional state goes from non-<code>nil</code> to <code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A Disposable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.iflet(then:)">
    <h3>
        <code><a href="#store.iflet(then:)">if​Let(then:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>An overload of <code>ifLet(then:else:)</code> for the times that you do not want to handle the <code>else</code>
case.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Void</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A Disposable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.iflet(and:then:else:)">
    <h3>
        <code><a href="#store.iflet(and:then:else:)">if​Let(and:​then:​else:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
    <span class="variable">and</span> <span class="variable">condition</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Wrapped</span>) -&gt; <span class="type">Bool</span>,
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>,
    <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> () -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Similar to <code>ifLet(then:else:)</code> where we add a condition on the wrapped state for <code>unwrap</code> to
be called. When the state is <code>nil</code> or <code>condition</code> is not met, <code>else</code> gets called.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>condition</th>
    <td><code class="type">@escaping (Wrapped) -&gt; Bool</code></td>
    <td><p>An extra condition on the wrapped state that needs to be true for <code>unwrap</code> to be called</p>
</td>
</tr>
<tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Void</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code> or <code>condition(state)</code> goes from <code>false</code> to <code>true</code></p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping () -&gt; Void</code></td>
    <td><p>A function that is called whenever the store's optional state goes from non-<code>nil</code> to <code>nil</code> or <code>condition(state)</code> goes from <code>true</code> to <code>false</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A Disposable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.iflet(and:then:)">
    <h3>
        <code><a href="#store.iflet(and:then:)">if​Let(and:​then:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">ifLet</span>&lt;<span class="variable">Wrapped</span>&gt;(
      <span class="variable">and</span> <span class="variable">condition</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Wrapped</span>) -&gt; <span class="type">Bool</span>,
      <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>An overload of <code>ifLet(condition:then:else:)</code> for the times that you do not want to handle
the <code>else</code> case.</p>

</div>
</div>
<div role="article" class="function" id="store.onceavailable(_:thenwhennil:)">
    <h3>
        <code><a href="#store.onceavailable(_:thenwhennil:)">once​Available(_:​then​When​Nil:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">onceAvailable</span>&lt;<span class="variable">Wrapped</span>, <span class="variable">Result</span>&gt;(
    <span class="keyword">_</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Result</span>,
    <span class="variable">thenWhenNil</span> <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Result</span>) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Variant of ifLet useful to perform push/pop or present/dismiss navigation operations
between UIKit controllers. Once the state becomes non-<code>nil</code>, <code>unwrap</code> gets called with store
of unwrapped state and returns a result. After that when the state goes back to being <code>nil</code>,
<code>else</code> gets called with the previously produced result. The result is captured by the closures
and is only released after <code>else</code> is called or the subscription is disposed.</p>

</div>
<div class="discussion">
    <html><body><pre class="highlight"><code> <span class="variable">store</span>.<span class="variable">scope</span>(<span class="variable">state</span>: { <span class="variable">$0</span>.<span class="variable">welcome</span> },
             <span class="variable">action</span>: { .<span class="variable">welcome</span>(<span class="variable">$0</span>) })
 .<span class="variable">onceAvailable</span>({ [<span class="variable">weak</span> <span class="variable">router</span>] <span class="variable">store</span> -&gt; <span class="type">Presentable</span> <span class="keyword">in</span>
     <span class="keyword">let</span> <span class="variable">presentable</span> = <span class="variable">presentableFactory</span>.<span class="variable">buildWelcomePresentable</span>(<span class="variable">store</span>: <span class="type">store</span>)
     <span class="variable">router</span>?.<span class="variable">push</span>(<span class="variable">presentable</span>: <span class="type">presentable</span>, <span class="variable">displayBackButton</span>: <span class="keyword">false</span>)
     <span class="keyword">return</span> <span class="variable">presentable</span>
 }, <span class="variable">thenWhenNil</span>: { [<span class="variable">weak</span> <span class="variable">router</span>] <span class="keyword">in</span>
     <span class="variable">router</span>?.<span class="variable">pop</span>(<span class="variable">presentable</span>: <span class="variable">$0</span>, <span class="variable">options</span>: .<span class="variable">init</span>())
 })
 .<span class="variable">disposed</span>(<span class="variable">by</span>: <span class="type">disposeBag</span>)
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Result</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code>. It returns a result that will be given to the <code>else</code> closure as soon as the store's optional state becomes <code>nil</code> again.</p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping (Result) -&gt; Void</code></td>
    <td><p>A function that is called whenever the store's optional state goes from non-<code>nil</code> to <code>nil</code>. It takes as parameter the result returned by <code>unwrap</code> when the state got populated. It is not called before a result has been produced aka before the state has been non-<code>nil</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A Disposable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.onceavailable(and:then:else:)">
    <h3>
        <code><a href="#store.onceavailable(and:then:else:)">once​Available(and:​then:​else:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">onceAvailable</span>&lt;<span class="variable">Wrapped</span>, <span class="variable">Result</span>&gt;(
    <span class="variable">and</span> <span class="variable">condition</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Wrapped</span>) -&gt; <span class="type">Bool</span>,
    <span class="variable">then</span> <span class="variable">unwrap</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>&lt;<span class="type">Wrapped</span>, <span class="type">Action</span>&gt;) -&gt; <span class="type">Result</span>,
    <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Result</span>) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">State</span> == <span class="type">Wrapped</span>?  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Variant of ifLet to perform push/pop or present/dismiss navigation operations between
UIKit controllers. Useful when the optional substate's reducer needs to perform loading
actions before it's ready to be displayed.</p>

</div>
<div class="discussion">
    <p>Its behavior is similar to <code>onceAvailable(unwrap:thenWhenNil:)</code> where :</p>

<p><code>unwrap</code> is called once the state is non-<code>nil</code> &amp; meets <code>condition</code></p>

<p><code>else</code> is called once the state is <code>nil</code> again or <code>condition</code> is not met anymore.</p>

<html><body><pre class="highlight"><code><span class="variable">selectionStore</span>.<span class="variable">onceAvailable</span>(
    <span class="variable">and</span>: { <span class="variable">$0</span>.<span class="variable">informationDisplayed</span> },
    <span class="variable">then</span>: { [<span class="variable">weak</span> <span class="variable">router</span>] <span class="variable">store</span> <span class="keyword">in</span>
        <span class="variable">router</span>?.<span class="variable">present</span>(
          <span class="variable">presentable</span>: <span class="type">presentableFactory</span>.<span class="variable">buildDislikedFoodInfo</span>(<span class="variable">store</span>: <span class="type">store</span>),
          <span class="variable">onDismiss</span>: { <span class="variable">store</span>.<span class="variable">send</span>(.<span class="variable">information</span>(.<span class="variable">modalDismissal</span>)) }
        )
    },
    <span class="variable">else</span>: { [<span class="variable">weak</span> <span class="variable">router</span>] <span class="keyword">in</span>
        <span class="variable">router</span>?.<span class="variable">dismissPresented</span>(<span class="variable">onCompletion</span>: <span class="keyword">nil</span>)
    }
)
.<span class="variable">disposed</span>(<span class="variable">by</span>: <span class="type">disposeBag</span>)
</code></pre></body></html>
</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>condition</th>
    <td><code class="type">@escaping (Wrapped) -&gt; Bool</code></td>
    <td><p>The condition to be met in addition to state being non-<code>nil</code></p>
</td>
</tr>
<tr>
    <th>unwrap</th>
    <td><code class="type">@escaping (Store&lt;Wrapped, Action&gt;) -&gt; Result</code></td>
    <td><p>A function that is called with a store of non-optional state whenever the store's optional state goes from <code>nil</code> to non-<code>nil</code> &amp; <code>condition</code> is met. It returns a result that will be given to the <code>else</code> closure as soon as the store's optional state becomes <code>nil</code> again or <code>condition</code> is not met anymore.</p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping (Result) -&gt; Void</code></td>
    <td><p>A function that is called whenever the store's optional state goes from non-<code>nil</code> to <code>nil</code> or <code>condition(state)</code> goes from <code>true</code> to <code>false</code>. It takes as parameter the result returned by <code>unwrap</code> when the state got populated. It is not called before a result has been produced aka before the state has been non-<code>nil</code> &amp; <code>condition(state)</code> has been true.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A Disposable associated with the underlying subscription.</p>

</div>
<div role="article" class="function" id="store.once(_:_:thenwhenfalse:)">
    <h3>
        <code><a href="#store.once(_:_:thenwhenfalse:)">once(_:​_:​then​When​False:​)</a></code>
    </h3>
    <div class="declaration">
<pre class="highlight"><code><html><body><span class="keyword">public</span> <span class="keyword">func</span> <span class="function">once</span>&lt;<span class="variable">Result</span>&gt;(
      <span class="keyword">_</span> <span class="variable">condition</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">State</span>) -&gt; <span class="type">Bool</span>,
      <span class="keyword">_</span> <span class="variable">buildResult</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<a href="/swift-composable-architecture/Store"><span class="type">Store</span></a>) -&gt; <span class="type">Result</span>,
      <span class="variable">thenWhenFalse</span> <span class="variable">else</span>: <span class="attribute">@</span><span class="attribute">escaping</span> (<span class="type">Result</span>) -&gt; <span class="type">Void</span>
  ) -&gt; <span class="type">Disposable</span>  </body></html></code></pre>
</div>
<div class="summary" role="doc-abstract">
    <p>Utility method that builds a result once <code>condition</code> is met.
Once the state matches <code>condition</code>, <code>buildResult</code> gets called with <code>self</code> and returns
a result. After that, when the state goes back to not matching <code>condition</code>,
<code>else</code> gets called with the previously produced result.
The result is captured by the closures and is only released after <code>else</code> is called or the
subscription is disposed.</p>

</div>
<h4>Parameters</h4>

<table class="parameters">
  <thead hidden>
  <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
    <th>condition</th>
    <td><code class="type">@escaping (State) -&gt; Bool</code></td>
    <td><p>The condition that will trigger the building of result</p>
</td>
</tr>
<tr>
    <th>build​Result</th>
    <td><code class="type">@escaping (Store) -&gt; Result</code></td>
    <td><p>A function that is called with current store once its state matches <code>condition</code>. It returns a result that will be given to the <code>else</code> closure as soon as the store's state doesn't match condition again.</p>
</td>
</tr>
<tr>
    <th>else</th>
    <td><code class="type">@escaping (Result) -&gt; Void</code></td>
    <td><p>A function that is called whenever the store's state stops matching <code>condition</code>. It takes as parameter the result returned by <code>buildResult</code> when the state last matched <code>condition</code>. It is not called before a result has been produced aka before <code>condition(state) == true</code>.</p>
</td>
</tr>
  </tbody>
</table>
  <h4>Returns</h4>
  <p>A Disposable associated with the underlying subscription.</p>

</div>
    </section>



        </article>
    </main>

    <footer>
        <p>
    Generated on <time datetime="2021-09-11T17:07:45+0000">September 11, 2021</time> using <a href="https://github.com/SwiftDocOrg/swift-doc">swift-doc</a> <span class="version">1.0.0-rc.1</span>.
</p>
    </footer>
</body>
</html>
